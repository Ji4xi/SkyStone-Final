package org.firstinspires.ftc.robotcontroller.internal.Default;

import android.icu.lang.UScript;

/**
 * The class is the PID control of the robot
 * PID is a adaptable control to allow the robot to travel with accuracy and efficiency
 * The PID ocnstants are experimentally found, general rule of thumb is D = 1/5 P
 */
public class PD {
    private double p, i, d; //adjusting constants for drivetrain: p, i, d
    private double error, time; //error: amount of distance left, time: the total amount of time
    private double dt, de; //dt = delta time, de = delta error
    private double integral = 0, differential = 0; //integral: area of error as a function of time, differential: de/dt
    private double target, timeSnip; //target: target distance, timeSnip: the temporary snippet of time

    private double threshold = 0; //lowest power output by PID

    public PD(double p, double i, double d) {
        this.p = p;
        this.i = i;
        this.d = d;
    }

    public double getP() {
        return p;
    }

    public double getI() {
        return i;
    }

    public double getD() {
        return d;
    }

    /**
     * set the target distance
     * @param target
     */
    public void initPD(double target) {
        this.target = Math.abs(target);
        this.time = System.nanoTime();
        this.error = target;
    }

    /**
     * adjust pid value in mid match
     * @param p
     * @param i
     * @param d
     */
    public void setPID(double p, double i, double d) {
        this.p = p;
        this.i = i;
        this.d = d;
    }

    public void differentiate() {
        differential = de / dt;
    }

    public double getPContrb() {
        return p * error;
    }
    public double getIContrb() {
        return i * integral;
    }
    public double getDContrb() {
        return d * differential;
    }

    /**
     * update the current position of the robot in respect to its destination
     * output the power generated by PID
     * @param current
     * @return
     */
    public double actuator(double current) {
        updatePD(current);
        differentiate();
        if (Math.abs(outputPower()) > 1) return 1; //cap the power
        else return outputPower();
    }

    public double outputPower() {
        return p * error + d * differential + i * integral; //calculate the product of PID
    }

    /**
     * update error and integral
     * @param current
     */
    public void updatePD(double current) {
        current = Math.abs(current);
        de = (target - current) - error;
        error = target - current;

        timeSnip = System.nanoTime();
        dt = (timeSnip - time) * Math.pow(10, -9);
        time = timeSnip;

        integral += error * dt;
        if (integral > 0.1) integral = 0.1; //saturation bound
    }
}

